Perfect choice 🙌 — let’s put together a **Product Requirements Document (PRD)** for **`go‑timecapsule`**.  
This should give you a clear spec of what the library does, why it exists, and how devs will use it.

---

# 📄 PRD: go‑timecapsule

### 1. **Overview**

`go‑timecapsule` is a lightweight Go library that lets developers **store values that are only retrievable after a specified time**.  
It acts like a “sealed envelope” or “time capsule” for objects, configs, or state.

---

### 2. **Problem Statement**

Small–mid companies often need to:

- Schedule **delayed actions** (e.g. send an email after 7 days).
- Store **future‑effective configs** (e.g. new pricing goes live next month).
- Implement **time‑locked features** (e.g. promo codes, trials).

Current approaches:

- Cron jobs → external, brittle.
- Timers/goroutines → memory leaks, fragile across restarts.
- DB “valid_from/valid_until” hacks → clunky boilerplate.

There’s **no simple Go‑native abstraction** for “don’t unlock this value until X time.”

---

### 3. **Goals & Non‑Goals**

**Goals**

- Provide a simple API to store/retrieve time‑locked values.
- Ensure values are only accessible after their unlock time.
- Support in‑memory and pluggable persistent backends (e.g. Redis, Postgres).
- Idiomatic Go API (structs, generics, `context.Context`).

**Non‑Goals**

- Not a full job scheduler.
- Not a distributed task queue.
- Not meant for millisecond‑precision scheduling (focus on minutes‑hours‑days).

---

### 4. **Target Users**

- **Small–mid SaaS teams** → need delayed actions but don’t want heavy infra.
- **Backend Go developers** → want clean abstractions over timers/DB hacks.
- **DevOps engineers** → want to schedule config/state changes without cron sprawl.

---

### 5. **Core Features**

#### v1 Features

- `Store(key, value, unlockTime)` → put a value in a capsule.
- `Open(key)` → retrieve value only if current time >= unlockTime.
- `Peek(key)` → check metadata without opening.
- In‑memory backend.
- Context support (timeouts, cancellation).
- Generics for type safety.

#### Future Features

- Persistent backends (Redis, Postgres, SQLite).
- TTL cleanup (auto‑purge expired capsules).
- Notifications/Callbacks when capsule unlocks.
- Encryption option for sealed data.

---

### 6. **Example API (Go)**

```go
import (
    "fmt"
    "time"
    "github.com/yourname/go-timecapsule"
)

type Promo struct {
    Code  string
    Discount int
}

func main() {
    capsule := timecapsule.New()

    // Store promo for future unlock
    capsule.Store("holiday-sale", Promo{Code: "XMAS50", Discount: 50},
        time.Now().Add(24*time.Hour))

    // Try to open now → locked
    if _, err := capsule.Open[Promo]("holiday-sale"); err != nil {
        fmt.Println("Capsule still locked:", err)
    }

    // Fast-forward for demo
    time.Sleep(2 * time.Second)

    // Open after unlock
    promo, err := capsule.Open[Promo]("holiday-sale")
    if err == nil {
        fmt.Printf("Promo unlocked: %+v\n", promo)
    }
}
```

---

### 7. **Technical Design**

- **In‑Memory Store**

  - Map of `key → Capsule{value, unlockTime, metadata}`.
  - Mutex for thread safety.

- **Capsule Struct**

  ```go
  type Capsule[T any] struct {
      Value      T
      UnlockTime time.Time
      CreatedAt  time.Time
  }
  ```

- **Access Logic**

  - `Open(key)` checks `time.Now()` vs `UnlockTime`.
  - If locked → returns error.
  - If unlocked → returns value.

- **Future Pluggable Backends**
  - Interface:
    ```go
    type Storage interface {
        Store(key string, value []byte, unlockTime time.Time) error
        Open(key string) ([]byte, error)
        Peek(key string) (Metadata, error)
    }
    ```

---

### 8. **Success Metrics**

- Dev adoption → GitHub stars, forks, contributions.
- Usage in real projects (issues, PRs with feature requests).
- Simplicity → developers can integrate in <5 minutes.

---

### 9. **Risks & Mitigations**

- **Risk:** Becomes “just another scheduler.”
  - ✅ Mitigation: Focus messaging on **time‑locked state**, not jobs.
- **Risk:** Developers misuse for high‑precision tasks.
  - ✅ Mitigation: Document that it’s best for hours‑days scheduling.
- **Risk:** Too niche.
  - ✅ Mitigation: Add fun use cases (promo unlocks, feature flags, trials).

---

### 10. **Why Unique?**

- Nobody has really treated **“time‑delayed state” as a primitive in Go**.
- It’s not a cron replacement, not a job queue — it’s a **new mental model**.
- Small, composable, but solves a real recurring headache.

---

👉 Next step:  
Do you want me to draft the **initial Go implementation skeleton** (with `Store`, `Open`, `Peek`) so you can see how simple the v1 code might look?
